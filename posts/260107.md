---
title: "JavaScriptのクラス継承と委譲"
date: "2026-01-07"
excerpt: "と、新年の挨拶"
---

出遅れましたが...あけましておめでとうございます🐎🌠

個人的に2025年は転職や引っ越しなど環境の変わるイベントが続き、楽しく過ごせました。

2026年も頑張ります。

---

## 本題

今回はJavaScriptのクラスの**継承**と**委譲**の使い分けについて整理します。

Reactは関数コンポーネントが登場してからしか知らないので^[（Reactを学習し始めた頃は、クラスコンポーネントの存在くらいはどの記事でも紹介されていた記憶...今はもう関数コンポーネントしか見ませんが。この辺りクラスコンポーネントの理解がもう少しあればクラスベースの設計についても理解が深まりそうではあります。）]、NestJSなどバックエンドフレームワークでのクラスベースの設計の理解がまだまだ足りていないです。

ここからは、NestJSでのバックエンド開発を想定しています。

## 継承とは

継承は「is-a（〜は〜である）」の関係を表します。

「**子クラスは、親クラスの一種である**」と自然に言えるものを指します。

クラス名の後ろに`extends Hoge`をつけて使用します。

```js
class Animal {
  eat() {
    console.log("食べる");
  }
}

class Dog extends Animal {
  bark() {
    console.log("吠える");
  }
}
```

これは「DogはAnimalの一種である」と言えます。
`Dog`は`Animal`が持つ振る舞いをそのまま使えます。

後ほど出てきますが、この「そのまま使っても問題ない」という点がポイントです。

### 継承の特徴

* 共通処理をまとめられる
* 型や振る舞いを揃えやすい
* 構造が固定される

## 委譲とは

委譲は「has-a（〜を持つ）」の関係です。

自分で処理を持つのではなく、**別のオブジェクトに処理を任せる**設計になります。

クラスのプロパティとして他のオブジェクトを保持し、必要な処理をそのオブジェクトに任せて使用します。

```js
class Logger {
  log(message) {
    console.log(message);
  }
}

class UserService {
  constructor() {
    this.logger = new Logger();
  }

  createUser() {
    this.logger.log("ユーザー作成");
  }
}
```

`UserService`は`Logger`ではありません。
ただし、ログ出力の責務を`Logger`に委ねています。

### 委譲の特徴

* クラス同士の結合が弱くなる
* 機能を差し替えやすい
* 組み合わせで振る舞いを作れる

NestJSのService層では、このような委譲ベースの設計が基本になります。

## 継承は問題になりやすい

継承は問題になりやすいため、慎重に利用する必要があります。
（書籍「良いコード悪いコードで学ぶ設計入門」^[[良いコード/悪いコードで学ぶ設計入門 ―保守しやすい 成長し続けるコードの書き方](https://www.amazon.co.jp/%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89-%E6%82%AA%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%81%A7%E5%AD%A6%E3%81%B6%E8%A8%AD%E8%A8%88%E5%85%A5%E9%96%80-%E2%80%95%E4%BF%9D%E5%AE%88%E3%81%97%E3%82%84%E3%81%99%E3%81%84-%E6%88%90%E9%95%B7%E3%81%97%E7%B6%9A%E3%81%91%E3%82%8B%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AE%E6%9B%B8%E3%81%8D%E6%96%B9-%E4%BB%99%E5%A1%B2/dp/4297127830/ref=sr_1_3?adgrpid=123448696210&dib=eyJ2IjoiMSJ9.wCudvM1lJDPbGRKCI7Wao58F6SURKTl5Pn90JP9I3raKwteDxmJ730YAzx8hbQZPtyJ4rjUwWaQ1NMUETrLMECcahes6qSAdyYtCbqxtjmecY61BMxyEjA45vmUUCJGCsD9iS0KCK_Zc3dz5K_O30Eq_bNcxlKarQRuQwaGIUPkx72MoWSCmG_7mPc6wXeylSqutJayDAWQa6fznqaoP7zDdaB6MHEcVDsfwozTT3sud0UiMbreryd4BJUlmM1wmak17XUgbSzaRaAOMoUAt_llc6yVjpBnp-WzT99mweQY.kxDkd7S1uUlCn0R2YtFliyl-jjs4POIM8wNOy6e_8b8&dib_tag=se&hvadid=770115117021&hvdev=c&hvexpln=0&hvlocphy=1009309&hvnetw=g&hvocijid=15794401922301909615--&hvqmt=e&hvrand=15794401922301909615&hvtargid=kwd-1643712552360&hydadcr=27271_14889734&jp-ad-ap=0&keywords=%E8%89%AF%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%2F%E6%82%AA%E3%81%84%E3%82%B3%E3%83%BC%E3%83%89%E3%81%A7%E5%AD%A6%E3%81%B6%E8%A8%AD%E8%A8%88%E5%85%A5%E9%96%80&mcid=a74a57284bd437a4938c8a4db0752e4b&qid=1767800561&sr=8-3)]に散々書かれているのはこれ）

### 理由１：親クラス変更の影響が大きい

継承では、親クラスの仕様変更がすべての子クラスに影響します。

一見正しい関係でも、子クラスごとに前提は違うため、親の変更が一部の子で破綻しやすくなります。

### 理由２：柔軟な拡張ができない

JavaScriptのクラスは単一継承です。

「AでもありBでもある」「状況によって振る舞いを変えたい」などの要件には継承は向いていません。

## じゃあ委譲を使おう

反対に、委譲は

* 処理単位で責務を分けられる
* 実装の差し替えが簡単
* テストしやすい

という性質を持っています。

例えば「支払い方法」を切り替えたい場合、継承よりも委譲の方が自然に書けます。

```js
class CreditCardPayment {
  pay() {}
}

class PayPayPayment {
  pay() {}
}

class OrderService {
  constructor(payment) {
    this.payment = payment;
  }

  checkout() {
    this.payment.pay();
  }
}
```

「何で支払うか」は`OrderService`の責務ではなく、支払い処理の実装に任せる、という考え方です。

## 　実際の使い分け

### 継承を選ぶ目安：

* is-a関係が明確
* 親クラスの振る舞いをほぼそのまま使う
* 階層が深くならない
* 共通化のためだけに使っている

### 委譲を選ぶ目安：

* has-a関係
* 機能単位で責務を分けたい
* 将来的に差し替え・拡張の可能性がある
* NestJSのService / Provider

つまり、迷ったら継承ではなく委譲を選ぶのが原則といえます。

---
